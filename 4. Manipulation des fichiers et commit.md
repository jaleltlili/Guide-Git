# Manipulation des fichiers et commit #
## 1. Gestion des fichiers et commit ##
<p>La fonction principale de Git est de suivre les différentes versions d'un projet. Un projet n'est rien d'autre qu'un ensemble de fichiers. De manière très pragmatique, Git ne s'intéresse qu'aux fichiers et ce sont les développeurs qui vont lui indiquer quels fichiers il doit suivre.</p>
<p> Le commit est l'élément central de Git. C'est la pierre angulaire qui permet de lier tous les éléments et tous les concepts de Git. Un commit représente un ensemble cohérent de modifications.</p>
<p>Par exemple, si un développeur corrige un bug, il va indiquer à Git le fichier dans lequel il a effectué la modification et Git va sauvegarder le fichier corrigé (tout en gardant l'ancienne version).</p>
## 2. Comment Git voit un fichier? ##
<p>Chaque fichier a une signature: Hash. C'est une valeur calculée à partir d'une autre valeur. Cette valeur est représentée sous forme d'une chaîne de caractères hexadécimaux.<br>Un hash fait toujours la même taille: 40 caractères</p>
<p>Les hashs sont souvent utilisés pour vérifier qu'un fichier n'est pas corrompu ou pour authentifier un utilisateur sans devoir stocker sont mot de passe en clair.</p>
### 2.1 Une identification par contenu ###
<p>En interne, Git travaille sur un certain nombre d'objets (contenus dans le dossier .git/objects): des fichiers, des dossiers, des commits, etc.</p>
<p>Tous les éléments que Git manipule sont en réalité rangés dans des dictionnaires de paires clé/valeur dont la clé est le hash calculé en fonction du contenu. En réalité, Git permet de stocker des informations (comme le contenu d'un fichier) et nous donne un identificateur (le hash) nous permettant de récupérer ces données.</p>
<p>C'est à dire que Git ne va pas identifier un fichier en fonction de son nom, mais plutôt à partir du hash généré à partir de son contenu. Cette méthode permet à Git de détecter facilement la moindre modification dans un fichier.</p>
## 3. Les trois zones d'un fichier ##
<p>Un fichier se trouve à trois endroits différents: le répertoire de travail, l'index et le dépôt. Le fichier va se trouver dans les différentes zones selon son avancée dans le projet.</p>
<p>Pour visualiser l'état des fichiers, nous allons utiliser la commande suivante: <br>
</p>
### 3.1 Le répertoire de travail ###
<p>Cette zone correspond au répertoire du système de fichiers sur lequel travaille le développeur. C'est le dossier du projet tel qu'il est stocké sur le disque dur. Les fichiers qui se trouvent dans cette zone peuvent être connus de Git selon qu'ils ont été ajoutés au moins une fois dans Git ou non. Un fichier qui se trouve uniquement dans cette zone est un fichier totalement inconnu pour Git. Ce genre de fichier est également appelé fichier non suivi (*intracked file*   en anglais). </p>
$ git init<br>
$ ls -la<br>
total 12
drwxr-xr-x 1 Jalel 197121 0 juin  10 17:04 ./<br>
drwxr-xr-x 1 Jalel 197121 0 juin  10 18:16 ../<br>
drwxr-xr-x 1 Jalel 197121 0 juin  10 19:32 .git/<br>
$ echo "Ce fichier est ds le rép. de travail" > fich.txt<br>
$ ls<br>
fich.txt<br>
La commande *git status* nous nous indique que le fichier est visualisé en tant que fichier non suivi:
<pre>
$ git status
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        fich.txt

nothing added to commit but untracked files present (use "git add" to track)</pre>
Le fichier *fich.txt* n'est pas suivi par Git. Il n'est pas encore identifié par Git et ne possède donc pas encore d'identifiant sous forme de hash. <br>
**NB :**  Git possède une commande de plomberie qui permet de visualiser les fichiers non suivis. Cette commande présente l'avantage d'afficher l'identifiant du fichier lorsque cet identifiant existe. 
<pre>$ git ls-files --others
fich.txt
</pre>

### 3.2 L'index ###
<p>Cette zone utilisée par Git est très particulière. C'est en quelque sorte une zonne d'attente de commit indépendante du répertoire de travail. On y placer les différents fichiers que nous voulons intégrer au prochain commit.<br>
Un fichier qui a été ajouté dans l'index ne sera plus considéré comme un fichier non suivi.</p>
<p>
Pour arriver à ce résultat, nous pouvons utiliser la commande suivante:
<pre>$ git add fich.txt
</pre>
Cette commande permet d'ajouter le fichier à l'index. <br>
La commande *git status* nous indique que le fichier est prêt à être commité:
<pre>
$ git status
On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

        new file:   fich.txt
</pre>
Cette indication de Git selon laquelle les fichiers sont prêts à être commités signifie qu'ils se situent dans l'index, qui est la zone d'attente avant le commit.<br>
**NB: ** La commande de plomberie *ls-files* va nous permettre d'afficher les fichiers présents dans l'index <pre>$ git ls-files
fich.txt
</pre> et l'identifiant sous forme de hash que Git leur a attribué.<br>
Voici la commande qui va nous permettre d'afficher ces éléments:
<pre>$ git ls-files --stage
100644 2b588c9df22ee5cc5fba32e1154ed4c566d21d9c 0       fich.txt
</pre>
Pour simplifier, nous remarquons que le fichier *fich.txt* a bien été ajouté à l'index et que son identifiant est la chaîne hexadécimale débutant par **2b588c9**. Le fait que Git a attribué un identifiant au contenu du fichier signifie que Git a correctement intégré le fichier dans son système. Cela ne signifie pas pour autant que le fichier est présent dans l'historique du dépôt. 
</p>
### 3.3 Le dépôt ###
